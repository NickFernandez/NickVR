<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Wiffle Ball VR</title>
        <link rel="shortcut icon" href="https://www.clipartmax.com/png/middle/26-269744_nice-usable-wiffle-ball-wiffle-ball-clip-art.png" />

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

        var createScene = async function () {
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);
            // Enable Havok physics in the scene.
            // const havokInstance = await HavokPhysics();
            // const hk = new BABYLON.HavokPlugin(true, havokInstance);
            // scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

            //  gravity using AmmoJS
            const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
            const physicsPlugin = new BABYLON.AmmoJSPlugin();
            scene.enablePhysics(gravityVector, physicsPlugin);
            // Once physics is enabled, you can access the physics engine instance through the physicsEngine property of the scene
            var physicsEngine = scene.getPhysicsEngine();
            physicsEngine.setSubTimeStep(8);

            // Creates and positions a free camera
            var camera = new BABYLON.ArcRotateCamera(
                "camera",
                BABYLON.Tools.ToRadians(90),
                BABYLON.Tools.ToRadians(65),
                10,
                BABYLON.Vector3.Zero(),
                scene
            );

            // Set the starting position of the camera
            camera.position = new BABYLON.Vector3(0, 1.6, 0.5);
            // This attaches the camera to the canvas
            camera.attachControl(canvas, true);
            camera.checkCollisions = true;

            var light = new BABYLON.PointLight("light", new BABYLON.Vector3(0, 10, 0), scene);
            light.intensity = 1;
            light.diffuse = new BABYLON.Color3(1, 1, 1); // Set the color of the light

            var ambientLight = new BABYLON.HemisphericLight("ambientLight", new BABYLON.Vector3(0, 1, 0), scene);
            ambientLight.intensity = 0.8;
            ambientLight.diffuse = new BABYLON.Color3(1, 1, 1); // Set the color of the ambient light

            // Our built-in 'ground' shape.
            var ground = BABYLON.MeshBuilder.CreateBox("ground", { width: 150, height: 1, depth: 150}, scene);
            ground.checkCollisions = true;
            ground.position.y = 0;
            ground.isPickable = false;
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.8, restitution: 0.1 }, scene);
            
            // Create a new StandardMaterial for the ground
            var groundMaterial = new BABYLON.StandardMaterial("Ground Material", scene);
            ground.material = groundMaterial;
            // Load the grass texture
            var grassTexture = new BABYLON.Texture("textures/grass.jpg", scene);
            // Apply the grass texture to the ground material
            groundMaterial.diffuseTexture = grassTexture;
            groundMaterial.diffuseTexture.uScale = 49;
            groundMaterial.diffuseTexture.vScale = 50;   

            // Add a skybox to the scene
            var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
            // Sky material
            var skyMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyMaterial.backFaceCulling = false;
            skyMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/TropicalSunnyDay", scene);
            skyMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyMaterial;
            skybox.isPickable = false;

            // Set sky properties for a blue sky
            skyMaterial.luminance = 1.5;
            skyMaterial.turbidity = 2;
            skyMaterial.rayleigh = 2;
            skyMaterial.mieCoefficient = 0.005;
            skyMaterial.mieDirectionalG = 0.8;

            // Load the sound and play it automatically once ready
            var soundBackyard = new BABYLON.Sound("summerbackyard", "sounds/summerbackyard.mp3", scene, null, { loop: true, autoplay: true });
            var soundCicadas = new BABYLON.Sound("cicadas", "sounds/cicadas.mp3", scene, null, { loop: false, autoplay: false });
            var soundLawnmower = new BABYLON.Sound("lawnmower", "sounds/lawnmower.mp3", scene, null, { loop: false, autoplay: true });
            var soundWindChimes = new BABYLON.Sound("chimes", "sounds/windchimes.mp3", scene, null, { loop: false, autoplay: true });
            var soundSprinkler = new BABYLON.Sound("sprinkler", "sounds/sprinkler.mp3", scene, null, { loop: false, autoplay: false });
            var soundIceCreamTruck = new BABYLON.Sound("icecreamtruck", "sounds/icecreamtruck.mp3", scene, null, { loop: false, autoplay: false });
            // Set the volume to a lower value (e.g., 0.5 for half volume)
            soundLawnmower.setVolume(0.4);
            soundWindChimes.setVolume(0.6);
            soundSprinkler.setVolume(0.5);
            soundIceCreamTruck.setVolume(0.5);
            // Function to play the sound effect
            function playSoundEffectCicadas() {
              soundCicadas.play();
            }
            // Function to play the sound effect
            function playSoundEffectLawnmower() {
              soundLawnmower.play();
            }
            // Function to play the sound effect
            function playSoundEffectWindChimes() {
              soundWindChimes.play();
            }
            // Function to play the sound effect
            function playSoundEffectSprinkler() {
              soundSprinkler.play();
            }
            // Function to play the sound effect
            function playSoundEffectIceCreamTruck() {
              soundIceCreamTruck.play();
            }
            // Schedule the cicadas sound effect (2:08 mins long) to play every 2 minutes (120,000 milliseconds)
            setInterval(playSoundEffectCicadas, 120000);
            // Schedule the lawnmower sound effect (4 mins long) to play every 13 minutes (780,000 milliseconds)
            setInterval(playSoundEffectLawnmower, 780000);
            // Schedule the wind chimes sound effect (35 seconds) to play every 5 minutes (300,000 milliseconds)
            setInterval(playSoundEffectWindChimes, 300000);
            // Schedule the sprinkler sound effect (1:45) to play every 8 minutes (480,000 milliseconds)
            setInterval(playSoundEffectSprinkler, 480000);
            // Schedule the ice cream truck sound effect (15 seconds) to play every 20 minutes (1,200,000 milliseconds)
            setInterval(playSoundEffectIceCreamTruck, 1200000);

            let fenceV;
            BABYLON.SceneLoader.ImportMesh("", "meshes/fence_vinyl/", "scene.gltf", scene, function (newMeshes){
                fenceV = newMeshes[0];
                fenceV.scaling = new BABYLON.Vector3(1, 1, 1);
                fenceV.position = new BABYLON.Vector3(0, 0.5, 30.48);
                fenceV.isPickable = false,

                // Gotta do this on each mesh
                fenceV.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                    });

                fenceV.physicsImpostor = new BABYLON.PhysicsImpostor(
                          fenceV,
                          BABYLON.PhysicsImpostor.NoImpostor,
                          { mass: 0, friction: 0.4, restitution: 0.2},
                          scene
                        );

                var clonedFenceVinyl = fenceV.clone("fenceV");
                clonedFenceVinyl.position = new BABYLON.Vector3(2.8, 0.5, 30.48);
                clonedFenceVinyl.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                    });
                clonedFenceVinyl.physicsImpostor = new BABYLON.PhysicsImpostor(
                    clonedFenceVinyl,
                    BABYLON.PhysicsImpostor.NoImpostor,
                    { mass: 0, friction: 0.4, restitution: 0.2},
                    scene
                );
                var clonedFenceVinyl2 = fenceV.clone("fenceV2");
                clonedFenceVinyl2.position = new BABYLON.Vector3(5.6, 0.5, 30.48);
                clonedFenceVinyl2.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl2.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl2,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );
                

                var clonedFenceVinyl3 = fenceV.clone("fenceV3");
                clonedFenceVinyl3.position = new BABYLON.Vector3(8.4, 0.5, 30.48);
                clonedFenceVinyl3.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl3.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl3,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl4 = fenceV.clone("fenceV4");
                clonedFenceVinyl4.position = new BABYLON.Vector3(11.2, 0.5, 30.48);
                clonedFenceVinyl4.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl4.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl4,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl5 = fenceV.clone("fenceV5");
                clonedFenceVinyl5.position = new BABYLON.Vector3(-2.8, 0.5, 30.48);
                clonedFenceVinyl5.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl5.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl5,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl6 = fenceV.clone("fenceV6");
                clonedFenceVinyl6.position = new BABYLON.Vector3(-5.6, 0.5, 30.48);
                clonedFenceVinyl6.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl6.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl6,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl7 = fenceV.clone("fenceVinyl7");
                clonedFenceVinyl7.position = new BABYLON.Vector3(-8.4, 0.5, 30.48);
                clonedFenceVinyl7.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl7.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl7,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl8 = fenceV.clone("fenceVinyl8");
                clonedFenceVinyl8.position = new BABYLON.Vector3(-11.2, 0.5, 30.48);
                clonedFenceVinyl8.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl8.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl8,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl9 = fenceV.clone("fence9");
                clonedFenceVinyl9.position = new BABYLON.Vector3(0, 0.5, -2);
                clonedFenceVinyl9.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl9.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl9,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl10 = fenceV.clone("fenceV10");
                clonedFenceVinyl10.position = new BABYLON.Vector3(-2.8, 0.5, -2);
                clonedFenceVinyl10.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl10.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl10,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl11 = fenceV.clone("fenceV11");
                clonedFenceVinyl11.position = new BABYLON.Vector3(2.8, 0.5, -2);
                clonedFenceVinyl11.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl11.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl11,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl16 = fenceV.clone("fenceV16");
                // clonedFenceVinyl16.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl16.position = new BABYLON.Vector3(5.6, 0.5, -2);
                clonedFenceVinyl16.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl16.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl16,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl17 = fenceV.clone("fenceV17");
                // clonedFenceVinyl17.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl17.position = new BABYLON.Vector3(-5.6, 0.5, -2);
                clonedFenceVinyl17.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl17.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl17,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl18 = fenceV.clone("fenceV18");
                // clonedFenceVinyl18.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl18.position = new BABYLON.Vector3(-8.4, 0.5, -2);
                clonedFenceVinyl18.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl18.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl18,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl19 = fenceV.clone("fenceVinyl19");
                // clonedFenceVinyl19.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl19.position = new BABYLON.Vector3(8.4, 0.5, -2);
                clonedFenceVinyl19.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl19.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl19,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl20 = fenceV.clone("fenceVinyl20");
                // clonedFenceVinyl20.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl20.position = new BABYLON.Vector3(-11.2, 0.5, -2);
                clonedFenceVinyl20.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl20.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl20,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl21 = fenceV.clone("fenceVinyl21");
                // clonedFenceVinyl21.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl21.position = new BABYLON.Vector3(11.2, 0.5, -2);
                clonedFenceVinyl21.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl21.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl21,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl22 = fenceV.clone("fenceVinyl22");
                clonedFenceVinyl22.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl22.position = new BABYLON.Vector3(-12.7, 0.5, -1);
                clonedFenceVinyl22.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl22.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl22,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl23 = fenceV.clone("fenceVinyl23");
                clonedFenceVinyl23.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl23.position = new BABYLON.Vector3(-12.7, 0.5, 1.8);
                clonedFenceVinyl23.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl23.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl23,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl24 = fenceV.clone("fenceVinyl24");
                clonedFenceVinyl24.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl24.position = new BABYLON.Vector3(-12.7, 0.5, 4.6);
                clonedFenceVinyl24.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl24.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl24,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl25 = fenceV.clone("fenceVinyl25");
                clonedFenceVinyl25.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl25.position = new BABYLON.Vector3(-12.7, 0.5, 7.4);
                clonedFenceVinyl25.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl25.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl25,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl32 = fenceV.clone("fenceVinyl32");
                clonedFenceVinyl32.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl32.position = new BABYLON.Vector3(-12.7, 0.5, 10.2);
                clonedFenceVinyl32.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl32.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl32,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl33 = fenceV.clone("fenceVinyl33");
                clonedFenceVinyl33.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl33.position = new BABYLON.Vector3(-12.7, 0.5, 13);
                clonedFenceVinyl33.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl33.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl33,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl34 = fenceV.clone("fenceVinyl34");
                clonedFenceVinyl34.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl34.position = new BABYLON.Vector3(-12.7, 0.5, 15.8);
                clonedFenceVinyl34.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl34.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl34,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl35 = fenceV.clone("fenceVinyl35");
                clonedFenceVinyl35.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl35.position = new BABYLON.Vector3(-12.7, 0.5, 18.6);
                clonedFenceVinyl35.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl35.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl35,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl36 = fenceV.clone("fenceVinyl36");
                clonedFenceVinyl36.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl36.position = new BABYLON.Vector3(-12.7, 0.5, 21.4);
                clonedFenceVinyl36.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl36.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl36,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl37 = fenceV.clone("fenceVinyl37");
                clonedFenceVinyl37.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl37.position = new BABYLON.Vector3(-12.7, 0.5, 24.2);
                clonedFenceVinyl37.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl37.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl37,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl38 = fenceV.clone("fenceVinyl38");
                clonedFenceVinyl38.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl38.position = new BABYLON.Vector3(-12.7, 0.5, 27);
                clonedFenceVinyl38.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl38.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl38,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl39 = fenceV.clone("fenceVinyl39");
                clonedFenceVinyl39.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl39.position = new BABYLON.Vector3(-12.7, 0.5, 28.6);
                clonedFenceVinyl39.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl39.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl39,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl40 = fenceV.clone("fenceVinyl40");
                clonedFenceVinyl40.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl40.position = new BABYLON.Vector3(12.6, 0.5, -1);
                clonedFenceVinyl40.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl40.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl40,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl41 = fenceV.clone("fenceVinyl41");
                clonedFenceVinyl41.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl41.position = new BABYLON.Vector3(12.6, 0.5, 1.8);
                clonedFenceVinyl41.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl41.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl41,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl42 = fenceV.clone("fenceVinyl42");
                clonedFenceVinyl42.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl42.position = new BABYLON.Vector3(12.6, 0.5, 4.6);
                clonedFenceVinyl42.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl42.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl42,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl43 = fenceV.clone("fenceVinyl43");
                clonedFenceVinyl43.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl43.position = new BABYLON.Vector3(12.6, 0.5, 6.26);
                clonedFenceVinyl43.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl43.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl43,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl44 = fenceV.clone("fenceVinyl44");
                clonedFenceVinyl44.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl44.position = new BABYLON.Vector3(12.6, 0.5, 23.29);
                clonedFenceVinyl44.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl44.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl44,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl45 = fenceV.clone("fenceVinyl45");
                clonedFenceVinyl45.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl45.position = new BABYLON.Vector3(12.6, 0.5, 26.09);
                clonedFenceVinyl45.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl45.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl45,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

                var clonedFenceVinyl46 = fenceV.clone("fenceVinyl46");
                clonedFenceVinyl46.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(90), BABYLON.Space.WORLD);
                clonedFenceVinyl46.position = new BABYLON.Vector3(12.6, 0.5, 28.65);
                clonedFenceVinyl46.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                  });
                clonedFenceVinyl46.physicsImpostor = new BABYLON.PhysicsImpostor(
                  clonedFenceVinyl46,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );
            });

            var home;
            BABYLON.SceneLoader.ImportMesh("", "meshes/home/", "scene.gltf", scene, function (newMeshes) {
                // The loaded mesh is returned as an array
                home = newMeshes[0];
                // Gotta do this on each mesh to make sure it isn't Pickable
                home.getChildMeshes().forEach((mesh) => {
                    mesh.isPickable = false;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                  });
                home.isPickable = false;
                home.scaling = new BABYLON.Vector3(0.0087, 0.0087, 0.0087);
                home.position = new BABYLON.Vector3(17, 0.25, 15);
                
                home.physicsImpostor = new BABYLON.PhysicsImpostor(home, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction:0.4, restitution:0.1 }, scene);
                home.physicsImpostor.isPickable = false;
                // Alternatively, you can use the following line to spin the house 180 degrees around the Y-axis
                home.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(270), BABYLON.Space.LOCAL);
                });

            // Our built-in 'sphere' shape.
            var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 32}, scene);
            const newColor = new BABYLON.Color3(0, 4, 1); //  blue
            const newMaterial = new BABYLON.StandardMaterial('blueMaterial', scene);
            newMaterial.diffuseColor = newColor;
            sphere.material = newMaterial;
            sphere.setParent(null);
            sphere.isPickable = true;
            // drop from a height
            sphere.position.y = 15;
            sphere.scaling = new BABYLON.Vector3(0.045, 0.045, 0.045);
            sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, {  mass: 1, friction: 0.4, restitution: 0.2 }, scene);
            sphere.physicsImpostor.physicsBody.setDamping(0.7, 0.6);
            sphere.physicsImpostor.isPickable = false;

            // old strike-zone
            var strikeZone = BABYLON.MeshBuilder.CreateBox("box", {}, scene);
            const newColorSZ = new BABYLON.Color3.FromHexString('#004fd8'); //  blue
            const newMaterialSZ = new BABYLON.StandardMaterial('szMaterial', scene);
            newMaterialSZ.diffuseColor = newColorSZ;
            strikeZone.material = newMaterialSZ;
            strikeZone.scaling = new BABYLON.Vector3(0.4572, 0.5588, 0.0762);
            strikeZone.position = new BABYLON.Vector3(0, 1.4786, 0);
            strikeZone.setParent(null);
            strikeZone.isPickable = false;
            strikeZone.physicsImpostor = new BABYLON.PhysicsImpostor(strikeZone, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.2, restitution: 0.3 }, scene);
            strikeZone.physicsImpostor.isPickable = false;

            // strike-zone pole
            var szPole = BABYLON.MeshBuilder.CreateCapsule("szPole", {radius:0.04, capSubdivisions: 1, height:1.5, tessellation:4, topCapSubdivisions:12}, scene);
            newMaterialSZPole = new BABYLON.StandardMaterial('szPoleMaterial', scene);
            newMaterialSZPole.diffuseColor = newColorSZ;
            szPole.material = newMaterialSZPole;
            szPole.scaling = new BABYLON.Vector3(1, 1, 1);
            szPole.position = new BABYLON.Vector3(0, 0.75, -0.35);
            szPole.setParent(null);
            szPole.isPickable = false;
            szPole.physicsImpostor = new BABYLON.PhysicsImpostor(szPole, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.2, restitution: 0.3 }, scene);
            szPole.physicsImpostor.isPickable = false;

            // strike-zone pole connector
            var szPole2 = BABYLON.MeshBuilder.CreateCapsule("szPole2", {radius:0.04, capSubdivisions: 1, height:0.4, tessellation:4, topCapSubdivisions:12}, scene);
            newMaterialSZPole2 = new BABYLON.StandardMaterial('szPoleMaterial2', scene);
            newMaterialSZPole2.diffuseColor = newColorSZ;
            szPole2.material = newMaterialSZPole2;
            szPole2.rotate(BABYLON.Axis.Z, BABYLON.Tools.ToRadians(90), BABYLON.Space.LOCAL);
            szPole2.rotate(BABYLON.Axis.X, BABYLON.Tools.ToRadians(90), BABYLON.Space.LOCAL);
            szPole2.scaling = new BABYLON.Vector3(1, 1, 1);
            szPole2.position = new BABYLON.Vector3(0, 1.45, -0.18);
            szPole2.setParent(null);
            szPole2.isPickable = false;
            szPole2.physicsImpostor = new BABYLON.PhysicsImpostor(szPole2, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.2, restitution: 0.3 }, scene);
            szPole2.physicsImpostor.isPickable = false;



            // Create a material for the red color
            const collisionColor = new BABYLON.Color3.FromHexString('#ff010a'); // Red color
            // const collisionMaterial = new BABYLON.StandardMaterial('collisionMaterial', scene);
            // collisionMaterial.diffuseColor = collisionColor;

            var wiffleBall;
            BABYLON.SceneLoader.ImportMesh("", "meshes/wiffle_ball/", "scene.gltf", scene, function (newMeshes) {
                // The loaded mesh is returned as an array
                let ballRootParent = newMeshes[0];
                wiffleBall = ballRootParent.getChildMeshes()[0];
                wiffleBall.setParent(null);
                ballRootParent.dispose();

                const newColor = new BABYLON.Color3(1, 1, 1); //  white
                const newMaterial = new BABYLON.StandardMaterial('newMaterial', scene);
                newMaterial.diffuseColor = newColor;

                wiffleBall.material = newMaterial;
                // Gotta do this on each mesh to make it white/add impostors
                wiffleBall.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.material = newMaterial;
                    // mass: 0.01984165
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, {  mass: 1, friction: 0.4, restitution: 0.5 }, scene);
                    mesh.physicsImpostor.physicsBody.setDamping(0.7, 0.6);
                  });

                wiffleBall.scaling = new BABYLON.Vector3(0.021, 0.021, 0.021);
                wiffleBall.position = new BABYLON.Vector3(0, 0, 11.58);
                wiffleBall.physicsImpostor = new BABYLON.PhysicsImpostor(wiffleBall, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, friction: 0.4, restitution: 0.5 }, scene);
                wiffleBall.physicsImpostor.forceUpdate = true;
                wiffleBall.physicsImpostor.isPickable = false;
                wiffleBall.physicsImpostor.physicsBody.setDamping(0.7, 0.6);
                

                // Register a collision event handler
                // if (wiffleBall.intersectsMesh(strikeZone, true)) {
                //   newMaterialSZ.diffuseColor = collisionColor;
                // } else {
                //   newMaterialSZ.diffuseColor = newColorSZ;
                // }

            });

            // Create a flat box mesh
            var pitchingRubber = BABYLON.MeshBuilder.CreateBox("pitchingRubber", { width: 0.50, height: 0.01, depth: 0.125 }, scene);

            // Set the color to white
            var pitchingRubberMaterial = new BABYLON.StandardMaterial("pitchingRubberMaterial", scene);
            pitchingRubberMaterial.diffuseColor = BABYLON.Color3.White();
            pitchingRubber.material = pitchingRubberMaterial;
            pitchingRubber.position = new BABYLON.Vector3(0, 0.5, 11.58);

            // Set the scaling to make it one foot long (adjust the scale factor as needed)
            pitchingRubber.scaling = new BABYLON.Vector3(1, 1, 1);


            var homePlate;
            BABYLON.SceneLoader.ImportMesh("", "meshes/home_plate/", "scene.gltf", scene, function (newMeshes) {
                // The loaded mesh is returned as an array
                homePlate = newMeshes[0];
                // Scale the mesh down by a factor of 0.01
                homePlate.scaling = new BABYLON.Vector3(.003, .003, .003);
                // Position the mesh
                homePlate.position = new BABYLON.Vector3(0, 0.5, 1);
                homePlate.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(180), BABYLON.Space.LOCAL);
                homePlate.isPickable = false;

                // Gotta do this on each mesh
                homePlate.getChildMeshes().forEach((mesh) => {
                    mesh.checkCollisions = true;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
                    mesh.isPickable = false;
                    });

                homePlate.physicsImpostor = new BABYLON.PhysicsImpostor(
                          homePlate,
                          BABYLON.PhysicsImpostor.NoImpostor,
                          { mass: 0, friction: 0.4, restitution: 0.2},
                          scene
                        );
            });

            // here we add XR support
            const xr = await scene.createDefaultXRExperienceAsync({
                floorMeshes: [ground],
                // inputOptions: {
                //   doNotLoadControllerMeshes: true;
                // }
            });
            xr.pointerSelection.maxPointerDistance = 1;
            // add features such as teleportation
            const featuresManager = xr.baseExperience.featuresManager; // or any other way to get a features manager
            featuresManager.enableFeature(BABYLON.WebXRFeatureName.TELEPORTATION, "stable" /* or latest */, {
                xrInput: xr.input,
                // add options here
                floorMeshes: [ground],
            });

            let meshLeft;
            let meshRight;
            let isMeshHeld = false; // Flag to track if a mesh item is held when squeezing

            let observers = {};
            let meshesUnderPointer = {};
            const tmpVec = new BABYLON.Vector3();
            const tmpRay = new BABYLON.Ray();
            tmpRay.origin = new BABYLON.Vector3();
            tmpRay.direction = new BABYLON.Vector3();
            let lastTimestamp = 0;
            const oldPos = new BABYLON.Vector3();
            let newBall = null;


            xr.input.onControllerAddedObservable.add((controller) => {
                controller.onMotionControllerInitObservable.add((motionController) => {
                
                const yButtonComponent = motionController.getComponent('y-button');
                yButtonComponent.onButtonStateChangedObservable.add(() => {
                  if (yButtonComponent.pressed) {
                    // Clone the wiffleBall object
                    if (wiffleBall) {
                      const clonedBall = wiffleBall.clone();
                      // Dispose of the original wiffleBall
                      wiffleBall.dispose();
                      clonedBall.position = new BABYLON.Vector3(0, 0.5, 11.58);
                      clonedBall.isVisible = true;
                      newBall = clonedBall;
                    }
                    if (newBall) {
                      const clonedBall2 = newBall.clone();
                      // Dispose of the original wiffleBall
                      newBall.dispose();
                      clonedBall2.position = new BABYLON.Vector3(0, 0.5, 11.58);
                      clonedBall2.isVisible = true;
                      newBall = clonedBall2;
                    }
                  }
                });
                const handness = motionController.handness;
                const squeezeComponent = motionController.getComponentOfType('squeeze');

                

                squeezeComponent.onButtonStateChangedObservable.add(() => {
                if (squeezeComponent.changes.pressed) {
                    if (squeezeComponent.pressed) {
                        // animate position
                        controller.getWorldPointerRayToRef(tmpRay, true);
                        tmpRay.direction.scaleInPlace(1.5);
                        const position = controller.grip ? controller.grip.position : controller.pointer.position;
                        
                        const meshUnderPointer = xr.pointerSelection.getMeshUnderPointer(controller.uniqueId);
                        if (!meshUnderPointer) {
                            isMeshHeld = false; // No mesh item is being held when squeezing
                            return;
                        }

                        if (handness === 'left') {

                            const animatable = BABYLON.Animation.CreateAndStartAnimation('meshmove',
                                meshUnderPointer, 'position', 30, 15, meshUnderPointer.position.clone(),
                                position.add(tmpRay.direction),
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                                new BABYLON.BezierCurveEase(0.3, -0.75, 0.7, 1.6), () => {
                                    if (!meshUnderPointer) return;
                                    meshesUnderPointer[controller.uniqueId] = meshUnderPointer;
                                    observers[controller.uniqueId] = xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {
                                        const delta = (xr.baseExperience.sessionManager.currentTimestamp - lastTimestamp);
                                        lastTimestamp = xr.baseExperience.sessionManager.currentTimestamp;
                                        controller.getWorldPointerRayToRef(tmpRay, true);
                                        tmpRay.direction.scaleInPlace(0.15);
                                        const position = controller.grip ? controller.grip.position : controller.pointer.position;
                                        tmpVec.copyFrom(position);
                                        tmpVec.addInPlace(tmpRay.direction);
                                        tmpVec.subtractToRef(oldPos, tmpVec);
                                        tmpVec.scaleInPlace(1000 / delta);
                                        meshesUnderPointer[controller.uniqueId].position.copyFrom(position);
                                        meshesUnderPointer[controller.uniqueId].position.addInPlace(tmpRay.direction);
                                        oldPos.copyFrom(meshesUnderPointer[controller.uniqueId].position);
                                        meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                                        meshesUnderPointer[controller.uniqueId].physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
                                    })
                                });
                        } else if (handness === 'right') {

                            const animatable = BABYLON.Animation.CreateAndStartAnimation('meshmove',
                                meshUnderPointer, 'position', 30, 15, meshUnderPointer.position.clone(),
                                position.add(tmpRay.direction),
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                                new BABYLON.BezierCurveEase(0.3, -0.75, 0.7, 1.6), () => {
                                    if (!meshUnderPointer) return;
                                    meshesUnderPointer[controller.uniqueId] = meshUnderPointer;
                                    observers[controller.uniqueId] = xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {
                                        const delta = (xr.baseExperience.sessionManager.currentTimestamp - lastTimestamp);
                                        lastTimestamp = xr.baseExperience.sessionManager.currentTimestamp;
                                        controller.getWorldPointerRayToRef(tmpRay, true);
                                        tmpRay.direction.scaleInPlace(0.15);
                                        const position = controller.grip ? controller.grip.position : controller.pointer.position;
                                        tmpVec.copyFrom(position);
                                        tmpVec.addInPlace(tmpRay.direction);
                                        tmpVec.subtractToRef(oldPos, tmpVec);
                                        tmpVec.scaleInPlace(1000 / delta);
                                        meshesUnderPointer[controller.uniqueId].position.copyFrom(position);
                                        meshesUnderPointer[controller.uniqueId].position.addInPlace(tmpRay.direction);
                                        oldPos.copyFrom(meshesUnderPointer[controller.uniqueId].position);
                                        meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                                        meshesUnderPointer[controller.uniqueId].physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
                                    })
                                });
                        }
                        isMeshHeld = true; // A mesh item is being held when squeezing

                    } else {
                        if (isMeshHeld) {
                            if (handness === 'left') {
                                
                                // throw the object
                                if (observers[controller.uniqueId] && meshesUnderPointer[controller.uniqueId]) {
                                    xr.baseExperience.sessionManager.onXRFrameObservable.remove(observers[controller.uniqueId]);
                                    observers[controller.uniqueId] = null;

                                    var vectorRight = new BABYLON.Vector3(3,0,0);
                                    var targetRotation = BABYLON.Quaternion.RotationAxis(vectorRight, Math.PI / 3);
                                    var scalingFactor = 15; // Adjust the scaling factor as needed
                                    // Scale the rotation axis
                                    vectorRight.scaleInPlace(scalingFactor);
                                    // targetRotation.scaleInPlace(scalingFactor);

                                    meshesUnderPointer[controller.uniqueId].physicsImpostor.rotationQuaternion = targetRotation;

                                    meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(tmpVec.scale(5));
                                    meshesUnderPointer[controller.uniqueId].physicsImpostor.setAngularVelocity(tmpVec.scale(5));
                                }
                
                            } else if (handness === 'right') {
                                // throw the object
                                if (observers[controller.uniqueId] && meshesUnderPointer[controller.uniqueId]) {
                                    xr.baseExperience.sessionManager.onXRFrameObservable.remove(observers[controller.uniqueId]);
                                    observers[controller.uniqueId] = null;
                            
                                    var vectorLeft = new BABYLON.Vector3(-3,0,0);
                                    var targetRotation = BABYLON.Quaternion.RotationAxis(vectorLeft, Math.PI / 3);
                                    var scalingFactor = 5; // Adjust the scaling factor as needed
                                    // Scale the rotation axis
                                    vectorLeft.scaleInPlace(scalingFactor);
                                    // targetRotation.scaleInPlace(scalingFactor);

                                    meshesUnderPointer[controller.uniqueId].physicsImpostor.rotationQuaternion = targetRotation;
                                    meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(tmpVec.scale(5));
                                    meshesUnderPointer[controller.uniqueId].physicsImpostor.setAngularVelocity(tmpVec.scale(5));
                                }
                            }
                        }
                        isMeshHeld = false; // Reset the flag after releasing the squeeze button

                    }
                }
                });
                });
            }); 
            
            // Define a flag variable to track the intersection state
            var isIntersecting = false;

            scene.registerBeforeRender(function() {
              if (wiffleBall && strikeZone) {
                if (wiffleBall.intersectsMesh(strikeZone, true)) {
                  // Set the flag to true if there is an intersection
                  isIntersecting = true;

                  // Set the color to red immediately upon intersection
                  newMaterialSZ.diffuseColor = collisionColor;

                  // Delay the color change back to the original after 3 seconds
                  setTimeout(function() {
                    isIntersecting = false;
                    newMaterialSZ.diffuseColor = newColorSZ;
                  }, 3000);
                } else if (!isIntersecting) {
                  // Only set the color to the original if no intersection and not waiting for the timeout
                  newMaterialSZ.diffuseColor = newColorSZ;
                }
              }
            });

            
            return scene;
        };

                window.initFunction = async function() {
                    await Ammo();

                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
                            
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
