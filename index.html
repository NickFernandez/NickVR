<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = async function () {
            await Ammo();
    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);
    // Enable Havok physics in the scene.
    // const havokInstance = await HavokPhysics();
    // const hk = new BABYLON.HavokPlugin(true, havokInstance);
    // scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);

    //  gravity using AmmoJS
    const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    const physicsPlugin = new BABYLON.AmmoJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);
    // Once physics is enabled, you can access the physics engine instance through the physicsEngine property of the scene
    // var physicsEngine = scene.getPhysicsEngine();
    // physicsEngine.setSubTimeStep(5);

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);

    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    // Add a skybox to the scene
     var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
     var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
     skyboxMaterial.backFaceCulling = false;
     skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
     skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
     skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
     skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
     skybox.material = skyboxMaterial;
     skybox.isPickable = false;

    // Our built-in 'ground' shape.
    var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 90, height: 90}, scene);
    ground.isPickable = false;
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.88, restitution: 0.2}, scene);
    ground.physicsImpostor.isPickable = false;
    
    // Our built-in 'sphere' shape.
    var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 32}, scene);
    sphere.setParent(null);
    sphere.isPickable = true;
    // drop from a height
    sphere.position.y = 15;
    sphere.scaling = new BABYLON.Vector3(0.6, 0.6, 0.6);
    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, {  mass: 1, friction: 0.4, restitution: 0.2 }, scene);
    sphere.physicsImpostor.isPickable = false;


    // test
    // Create a wall mesh
    var wallWidth = 4;
    var wallHeight = 2;
    var wallDepth = 0.2;
    var wallPosition = new BABYLON.Vector3(0, wallHeight/2, 15);

    var wall = BABYLON.MeshBuilder.CreateBox("wall", { width: wallWidth, height: wallHeight, depth: wallDepth }, scene);
    wall.position = wallPosition;
    wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.88, restitution: 0.2}, scene);
    wall.physicsImpostor.isPickable = false;

//    let fence;
//    var mymat = new BABYLON.StandardMaterial("myMaterial", scene);
    // mymat.diffuseTexture = new BABYLON.Texture("https://raw.githubusercontent.com/NickFernandez/NickVR/blob/meshes/fencing_wood/textures/Scene_-_Root_baseColor.jpeg", scene);
    // mymat.specularTexture = new BABYLON.Texture("https://raw.githubusercontent.com/Datn7/myMeshes/master/yumbaraFBX_lambert1_Roughness.png", scene);
    // mymat.bumpTexture = new BABYLON.Texture("https://raw.githubusercontent.com/NickFernandez/NickVR/blob/main/meshes/wiffle_ball/wiffle_ball_2_normal.png", scene);

    // function assignPhysicsImpostor(mesh) {
    //     mesh.checkCollisions = true;
    //     mesh.physicsImpostor = new BABYLON.PhysicsImpostor(
    //         mesh,
    //         BABYLON.PhysicsImpostor.BoxImpostor,
    //         { mass: 0, friction: 0.4, restitution: 0.2 },
    //         scene
    //     );
    //     mesh.isPickable = false;

    //     if (mesh.getChildMeshes) {
    //         const childMeshes = mesh.getChildMeshes();
    //         for (let i = 0; i < childMeshes.length; i++) {
    //         assignPhysicsImpostor(childMeshes[i]);
    //         }
    //     }
    // }

    let fence;
   BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/NickFernandez/NickVR/main/meshes/fence_wood/", "scene.gltf", scene, function(newMeshes){
        fence = newMeshes[0];
        fence.scaling = new BABYLON.Vector3(2, 2 ,2);
        fence.position = new BABYLON.Vector3(-4, 0, 5);
        fence.isPickable = false,

        // Gotta do this on each mesh
        fence.getChildMeshes().forEach((mesh) => {
            mesh.checkCollisions = true;
            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
            mesh.isPickable = false;
            });

        fence.physicsImpostor = new BABYLON.PhysicsImpostor(
                  fence,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );


        });

    let fenceV;
    BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/NickFernandez/NickVR/main/meshes/fence_vinyl/", "scene.gltf", scene, function(newMeshes){
        fenceV = newMeshes[0];
        fenceV.scaling = new BABYLON.Vector3(1, 1, 1);
        fenceV.position = new BABYLON.Vector3(0, 0, 5);
        fenceV.isPickable = false,

        // Gotta do this on each mesh
        fenceV.getChildMeshes().forEach((mesh) => {
            mesh.checkCollisions = true;
            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {  mass: 0, friction: 0.4, restitution: 0.2 }, scene);
            mesh.isPickable = false;
            });

        fenceV.physicsImpostor = new BABYLON.PhysicsImpostor(
                  fenceV,
                  BABYLON.PhysicsImpostor.NoImpostor,
                  { mass: 0, friction: 0.4, restitution: 0.2},
                  scene
                );

        // Create a simplified bounding box
        // var boundingBox = BABYLON.MeshBuilder.CreateBox(newMeshes, { width: fence.scaling.x, height: fence.scaling.y, depth: fence.scaling.z }, scene); // Set initial size to 1, 1, 1
        // boundingBox.isVisible = false;

        // Scale the bounding box to match the size of the imported mesh
        // var boundingBoxSize = fence.getBoundingInfo().boundingBox.extendSize;
        // boundingBox.scaling = new BABYLON.Vector3(boundingBoxSize.x * 2, boundingBoxSize.y * 2, boundingBoxSize.z * 2);

        // boundingBox.position = fence.position;
        // boundingBox.rotationQuaternion = fence.rotationQuaternion;

        // Assign physics impostor using BoxImpostor
        // assignPhysicsImpostor(boundingBox);
        // boundingBox.physicsImpostor = new BABYLON.PhysicsImpostor(
        //     boundingBox,
        //     BABYLON.PhysicsImpostor.BoxImpostor,
        //     { mass: 0, friction: 0.4, restitution: 0.2 },
        //     scene
        // );

        // assignPhysicsImpostor(fence);

        });
    physicsViewer = new BABYLON.Debug.PhysicsViewer();
            for (const mesh of scene.rootNodes) {
                if (mesh.physicsImpostor) {
                const debugMesh = physicsViewer.showImpostor(mesh.physicsImpostor);
                }
            }

    // here we add XR support
    const xr = await scene.createDefaultXRExperienceAsync({
        floorMeshes: [ground],
        // inputOptions: {
        //   doNotLoadControllerMeshes: true;
        // }
    });
    xr.pointerSelection.maxPointerDistance = 1;
    // add features such as teleportation
    const featuresManager = xr.baseExperience.featuresManager; // or any other way to get a features manager
    featuresManager.enableFeature(BABYLON.WebXRFeatureName.TELEPORTATION, "stable" /* or latest */, {
        xrInput: xr.input,
        // add options here
        floorMeshes: [ground],
    });
    
    const xrPhysics = xr.baseExperience.featuresManager.enableFeature(
        BABYLON.WebXRFeatureName.PHYSICS_CONTROLLERS,
        "latest",
        {
            xrInput: xr.input,
            physicsProperties: {
                restitution: 0.5,
                impostorSize: 0.1,
                impostorType: BABYLON.PhysicsImpostor.BoxImpostor
            },
        }
    ) 

    let meshLeft;
    let meshRight;
    let isMeshHeld = false; // Flag to track if a mesh item is held when squeezing

    let observers = {};
    let meshesUnderPointer = {};
    const tmpVec = new BABYLON.Vector3();
    const tmpRay = new BABYLON.Ray();
    tmpRay.origin = new BABYLON.Vector3();
    tmpRay.direction = new BABYLON.Vector3();
    let lastTimestamp = 0;
    const oldPos = new BABYLON.Vector3();


    xr.input.onControllerAddedObservable.add((controller) => {
        controller.onMotionControllerInitObservable.add((motionController) => {
        const handness = motionController.handness;
        // const xr_ids = motionController.getComponentIds();
        // const triggerComponent = motionController.getComponent(xr_ids[0]); // xr-standard-trigger
        const squeezeComponent = motionController.getComponentOfType('squeeze');
        squeezeComponent.onButtonStateChangedObservable.add(() => {
        if (squeezeComponent.changes.pressed) {
            if (squeezeComponent.pressed) {
                // animate position
                controller.getWorldPointerRayToRef(tmpRay, true);
                tmpRay.direction.scaleInPlace(1.5);
                const position = controller.grip ? controller.grip.position : controller.pointer.position;
                
                const meshUnderPointer = xr.pointerSelection.getMeshUnderPointer(controller.uniqueId);
                if (!meshUnderPointer) {
                    isMeshHeld = false; // No mesh item is being held when squeezing
                    return;
                }
                // meshUnderPointer.setParent(controller.uniqueId.rootMesh);
                if (handness === 'left') {
                    // meshLeft = meshUnderPointer;
                    // meshLeft.physicsImpostor.dispose();
                    // meshLeft && meshLeft.setParent(motionController.rootMesh);
                    const animatable = BABYLON.Animation.CreateAndStartAnimation('meshmove',
                        meshUnderPointer, 'position', 30, 15, meshUnderPointer.position.clone(),
                        position.add(tmpRay.direction),
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                        new BABYLON.BezierCurveEase(0.3, -0.75, 0.7, 1.6), () => {
                            if (!meshUnderPointer) return;
                            meshesUnderPointer[controller.uniqueId] = meshUnderPointer;
                            observers[controller.uniqueId] = xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {
                                const delta = (xr.baseExperience.sessionManager.currentTimestamp - lastTimestamp);
                                lastTimestamp = xr.baseExperience.sessionManager.currentTimestamp;
                                controller.getWorldPointerRayToRef(tmpRay, true);
                                tmpRay.direction.scaleInPlace(1.5);
                                const position = controller.grip ? controller.grip.position : controller.pointer.position;
                                position.y = -0.25;
                                tmpVec.copyFrom(position);
                                tmpVec.addInPlace(tmpRay.direction);
                                tmpVec.subtractToRef(oldPos, tmpVec);
                                tmpVec.scaleInPlace(1000 / delta);
                                meshesUnderPointer[controller.uniqueId].position.copyFrom(position);
                                meshesUnderPointer[controller.uniqueId].position.addInPlace(tmpRay.direction);
                                oldPos.copyFrom(meshesUnderPointer[controller.uniqueId].position);
                                meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                                meshesUnderPointer[controller.uniqueId].physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
                            })
                        });
                } else if (handness === 'right') {
                    // meshRight = meshUnderPointer;
                    // meshRight.physicsImpostor.dispose();   
                    // meshRight && meshRight.setParent(motionController.rootMesh);
                    const animatable = BABYLON.Animation.CreateAndStartAnimation('meshmove',
                        meshUnderPointer, 'position', 30, 15, meshUnderPointer.position.clone(),
                        position.add(tmpRay.direction),
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                        new BABYLON.BezierCurveEase(0.3, -0.75, 0.7, 1.6), () => {
                            if (!meshUnderPointer) return;
                            meshesUnderPointer[controller.uniqueId] = meshUnderPointer;
                            observers[controller.uniqueId] = xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {
                                const delta = (xr.baseExperience.sessionManager.currentTimestamp - lastTimestamp);
                                lastTimestamp = xr.baseExperience.sessionManager.currentTimestamp;
                                controller.getWorldPointerRayToRef(tmpRay, true);
                                tmpRay.direction.scaleInPlace(1.5);
                                const position = controller.grip ? controller.grip.position : controller.pointer.position;
                                tmpVec.copyFrom(position);
                                tmpVec.addInPlace(tmpRay.direction);
                                tmpVec.subtractToRef(oldPos, tmpVec);
                                tmpVec.scaleInPlace(1000 / delta);
                                meshesUnderPointer[controller.uniqueId].position.copyFrom(position);
                                meshesUnderPointer[controller.uniqueId].position.addInPlace(tmpRay.direction);
                                oldPos.copyFrom(meshesUnderPointer[controller.uniqueId].position);
                                meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                                meshesUnderPointer[controller.uniqueId].physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
                            })
                        });
                }
                isMeshHeld = true; // A mesh item is being held when squeezing

            } else {
                if (isMeshHeld) {
                    if (handness === 'left') {
                        
                        // throw the object
                        if (observers[controller.uniqueId] && meshesUnderPointer[controller.uniqueId]) {
                            xr.baseExperience.sessionManager.onXRFrameObservable.remove(observers[controller.uniqueId]);
                            observers[controller.uniqueId] = null;
                            meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(tmpVec);
                        }
        
                    } else if (handness === 'right') {
                        // throw the object
                        if (observers[controller.uniqueId] && meshesUnderPointer[controller.uniqueId]) {
                            xr.baseExperience.sessionManager.onXRFrameObservable.remove(observers[controller.uniqueId]);
                            observers[controller.uniqueId] = null;
                            meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(tmpVec);
                        }
                    }
                }
                isMeshHeld = false; // Reset the flag after releasing the squeeze button

            }
        }
        });
        });
    }); 

    
    return scene;
};
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
                            
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
